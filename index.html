<!DOCTYPE html>
<html>
<style>
    body {
        font-family: Monospace;
        background-color: #fff;
        color: #000;
        margin: 0px;
        overflow: hidden;
    }

    #about {
        margin: 0px;
        border: 3px solid #fff;
        width: 870px;
        height: 90%;
        position: absolute;
        margin-top: 50px;
        top: 0px;
        /* to center: 
            left: 50%;
            margin-left: -435px; 
            */
        left: 50px;
        z-index: 4;
        font-size: 20px;
        color: white;
        display: none;
        background-color: #000;
        opacity: 0.8;
        filter: progid:DXImageTransform.Microsoft.Gradient(GradientType=0, StartColorStr='#CC000000', EndColorStr='#CC000000');
    }

    .codearea {
        margin: 10px;
        width: 850px;
        height: 40%;
        color: white;
        background-color: #000;
        font-size: 14px;
    }
</style>

<head>

    <meta charset="utf-8">
    <title>Lens Renderer</title>
    <style src="webgl/style.css"></style>
</head>

<body>
    <!-- SHADERS -->
    <script id="phong-vs-glsl" type="x-shader/x-vertex" src="./shaders/phong-vs.vert.glsl">
        varying vec3 vNormal;
        varying vec3 vPos;
        void main(){
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            vPos = (modelViewMatrix * vec4(position, 1.0)).xyz;
            vNormal = normalMatrix * normal;
            gl_Position.z += 0.0001; //for wireframe z-fighting
        }
    </script>
    <script id="phong-ps-glsl" type="x-shader/x-fragment" src="./shaders/phong-ps.frag.glsl">
        varying vec3 vNormal;
        varying vec3 vPos;
        #if NUM_POINT_LIGHTS > 0
            struct PointLight {
                vec3 position;
                vec3 color;
            };
            uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
        #endif	
        uniform vec3 ambientLightColor;
        uniform vec3 mDiffuse;
        uniform vec3 mAmbient;
        uniform vec3 mSpecular;
        uniform float mShininess;
        uniform float mKa;
        uniform float mKd;
        uniform float mKs;
        void main() {	
            vec3 N = normalize(vNormal);
            vec3 V = normalize(-vPos);
            vec3 lDif = vec3(0.0, 0.0, 0.0);
            float lSpec = 0.0;
            for(int l = 0; l < NUM_POINT_LIGHTS; l++) {
                vec3 L = normalize(pointLights[l].position - vPos);
                float lamb = clamp(dot(L, N), 0.0, 1.0);
                lDif += lamb * pointLights[l].color;
                if(lamb > 0.0) {
                    vec3 R = reflect(-L, N);
                    float specAngle = max(dot(R, V), 0.0);
                    lSpec += pow(specAngle, mShininess);
                }
            }
            gl_FragColor = vec4(mKa * ambientLightColor * mAmbient +
                                mKd * lDif * mDiffuse +
                                mKs * lSpec * mSpecular, 1.0);
        }
    </script>
    <script id="screen-vs-glsl" type="x-shader/x-vertex" src="./shaders/screen.vert.glsl">
        varying vec2 vUv;

        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    </script>
    <script id="screen-ps-glsl" type="x-shader/x-fragment" src="./shaders/screen.frag.glsl">
        varying vec2 vUv;
        uniform sampler2D tDiffuse;
        
        void main() { 
            // vec2 fragmentScreenCoordinates = vec2(gl_FragCoord.x / _ScreenParams.x, gl_FragCoord.y / _ScreenParams.y);
            // vec4 tex = texture2D(tDiffuse, fragmentScreenCoordinates); 
            vec4 tex = texture2D(tDiffuse, vUv); 
            gl_FragColor = tex; 
        }
    </script>
    <script id="lens-vs-glsl" type="x-shader/x-vertex" src="./shaders/lens.vert.glsl">
        varying vec2 vUv;

        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    </script>
    <script id="lens-ps-glsl" type="x-shader/x-fragment" src="./shaders/lens.frag.glsl">
        uniform sampler2D tDiffuse;
        uniform float lensRadius1;
        uniform float lensRadius2;
        uniform float lensDiameter;
        uniform float lensWidth;
        uniform float chroma;
        uniform vec3 lensPosition;
        uniform float eta[6];
        uniform vec2 screen;
        
        vec4 raycirc(vec3 orig, vec3 ray, vec3 center, float radius, float sign) {
            float r2 = radius * radius;
            vec3 L = center - orig;
            float tca = dot(L, ray);
            float d2 = dot(L, L) - tca * tca;
            float d = sqrt(d2);
            float thc = sqrt(max(r2 - d2, 0.));
            return vec4(orig + (tca - sign * thc) * ray, r2 >= d2);
        }
        
        vec3 rayplane(vec3 orig, vec3 ray, float wallZ) {
            vec3 p0 = vec3(0, 0, wallZ);
            vec3 l0 = orig;
            vec3 n = vec3(0, 0, -1);
            float d = (p0 - l0).z / ray.z;
            // float d = dot(p0 - l0, n) / dot(ray, n);
            return orig + ray * d;
        }
        
        void main() {
            float flip = 1.;
            // float wallZ=100.;
            float wallZ = gl_FragCoord.z;
            float r1 = lensRadius1 * 30000.;
            float r2 = lensRadius2 * 30000.;
            float lr = lensDiameter / 2.;
        
            // The center of the lens
            vec3 lensPos = vec3(lensPosition.xy, 0);
        
            // Calculate the center of curvature of the front face of the lens
            float tmp1 = sqrt(r1 * r1 - lr * lr) * sign(r1) * flip;
            vec3 lensCenter1 = lensPos + vec3(0, 0, -(lensWidth / 2. - tmp1));
        
            // Calculate the center of curvature of the back face of the lens
            float tmp2 = sqrt(r2 * r2 - lr * lr) * sign(r2) * flip;
            vec3 lensCenter2 = lensPos + vec3(0, 0, (lensWidth / 2. - tmp2));
        
            // First ray from the 'camera'(center of lens but back) towards the FragCoord
            vec3 cameraCenter = vec3(lensPosition.xy, -lensPosition.z);
            vec3 ray = normalize(gl_FragCoord.xyz - cameraCenter);
        
            // Intersect the front face of the lens (using standard ray-circle intersection)
            vec4 frontFaceHit = raycirc(cameraCenter, ray, lensCenter1, r1, flip);
            vec3 frontFaceNormal = normalize(frontFaceHit.xyz - lensCenter1);
        
            vec3 colors[6];
            float eta_i;
            vec3 ray2, backFaceNormal, ray3, intersection3;
            vec4 backFaceHit;
            // Project 6 rays according to different color components (with different refractive indices)
        #pragma unroll_loop_start
            for (int i = 0; i < 6; i++) {
                eta_i = 1. / eta[i] / eta[i];
                // Refract through the front face
                ray2 = refract(ray, frontFaceNormal, eta_i);
        
                // Intersect the back face (using new ray)
                backFaceHit = raycirc(frontFaceHit.xyz, ray2, lensCenter2, r2, -flip);
                backFaceNormal = normalize(backFaceHit.xyz - lensCenter2);
        
                // Refract through the back face
                ray3 = refract(ray2, backFaceNormal, eta_i);
        
                // Intersect with the 'back wall' (aka original scene)
                intersection3 = rayplane(backFaceHit.xyz, ray3, chroma);
        
                // sample the texture
                colors[i] = texture2D(tDiffuse, intersection3.xy / screen.xy).rgb;
            }
        #pragma unroll_loop_end
        
            // This should simulate dispersion
            // 6 color component distribution comes from this paper;
            // https://web.archive.org/web/20061128135550/http://home.iitk.ac.in/~shankars/reports/dispersionraytrace.pdf
            // Take one color component from each ray
            float r = colors[0].r * .5;
            float y = dot(vec3(2., 2., -1.), colors[1]) / 6.;
            float g = colors[2].g * .5;
            float c = dot(vec3(-1., 2., 2.), colors[3]) / 6.;
            float b = colors[4].b * .5;
            float v = dot(vec3(2., -1., 2.), colors[5]) / 6.;
            // mix the color components
            float R = r + (2. * v + 2. * y - c) / 3.;
            float G = g + (2. * y + 2. * c - v) / 3.;
            float B = b + (2. * c + 2. * v - y) / 3.;
            vec4 mixed = vec4(R, G, B, 1);
        
            // Only render the parts where the ray actually hits the lens, otherwise there are artifacts
            float alpha = frontFaceHit.a;
            gl_FragColor = texture2D(tDiffuse, gl_FragCoord.xy / screen.xy) * (1. - alpha) + mixed * alpha;
        }
    </script>

    <script src="webgl/Stats.js"></script>
    <script src="webgl/three.js"></script>
    <script src="webgl/dat.gui.js"></script>
    <script src="webgl/cfg.js"></script>
    <script src='webgl/DragControls.js'></script>
    <script src='webgl/OrbitControls.js'></script>
    <script src="webgl/gui.js"></script>
    <script src="webgl/scene.js"></script>
    <script src="webgl/app.js"></script>
    <script>
        function hideAbout() {
            var about = document.getElementById("about");
            about.style.display = "none";
        }
    </script>
    <div id="about" onclick="hideAbout();" style="display:none">
        <center>COMP5411 Rendering Project - Lens Renderer</center>
        <p>By Anshuman Medhi and Aaron Wang</p>
    </div>
</body>

</html>